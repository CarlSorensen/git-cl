#!/usr/bin/python
# git-cl -- a git-command for integrating reviews on Rietveld
# Copyright (C) 2008 Evan Martin <martine@danga.com>

import os
import re
import subprocess
import sys
import textwrap
import upload
import urllib2

VERBOSE=False

def RunCommand(cmd, error_ok=False, error_message=None, exit_code=False):
  if VERBOSE:
    print >>sys.stderr, ' '.join(cmd)
  proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
  output = proc.communicate()[0]
  if exit_code:
    return proc.returncode
  if not error_ok and proc.returncode != 0:
    print >>sys.stderr, 'Command "%s" failed.' % (' '.join(cmd))
    if error_message:
      print >>sys.stderr, error_message
    else:
      print >>sys.stderr, output
    sys.exit(1)
  return output


class Settings:
  def __init__(self):
    self.server = None
    self.cc = None

  def GetServer(self):
    if not self.server:
      error_message = ('You must set your server with ' +
                       '"git config rietveld.server <hostname>[:<port>]".')
      self.server = self._GetConfig('rietveld.server',
                                    error_message=error_message)
    return self.server

  def GetCCList(self):
    if self.cc is None:
      self.cc = self._GetConfig('rietveld.cc', error_ok=True)
    return self.cc

  def _GetConfig(self, param, **kwargs):
    return RunCommand(['git', 'config', param], **kwargs).strip()

settings = Settings()


class IssueStore:
  def __init__(self):
    self.storepath = None
    self.issues = None

  def GetStorePath(self):
    if not self.storepath:
      gitdir = RunCommand(['git', 'rev-parse', '--git-dir']).strip()
      self.storepath = os.path.join(gitdir, 'cl-mapping')
    return self.storepath

  def LoadIssues(self):
    self.issues = {}
    if not os.path.exists(self.GetStorePath()):
      return
    store = open(self.GetStorePath(), 'r')
    for line in store:
      branch, issue = line.split()
      self.issues[branch] = issue
    store.close()

  def LookupIssue(self, branch):
    if not self.issues:
      self.LoadIssues()
    if branch in self.issues:
      return self.issues[branch]
    return None

  def FlushIssues(self):
    store = open(self.GetStorePath(), 'w')
    for branch, issue in self.issues.items():
      store.write('%s %s\n' % (branch, issue))
    store.close()

  def SetIssue(self, branch, issue):
    if not self.issues:
      self.LoadIssues()
    self.issues[branch] = issue
    self.FlushIssues()

  def DropBranchIssue(self, branch):
    del self.issues[branch]
    self.FlushIssues()

issuestore = IssueStore()


class Changelist:
  def __init__(self):
    self.branch = None
    self.has_issue = False
    self.issue = self.GetIssue()
    self.has_description = False
    self.description = None

  def GetBranch(self):
    if not self.branch:
      self.branchref = RunCommand(['git', 'symbolic-ref', 'HEAD']).strip()
      self.branch = self.branchref.replace('refs/heads/', '')
    return self.branch
  def GetBranchRef(self):
    self.GetBranch()
    return self.branchref

  def GetIssue(self):
    if not self.has_issue:
      self.issue = issuestore.LookupIssue(self.GetBranchRef())
      self.has_issue = True
    return self.issue

  def GetIssueURL(self):
    return 'http://%s/%s' % (settings.GetServer(), self.GetIssue())

  def GetDescription(self, pretty=False):
    if not self.has_description:
      if self.GetIssue():
        url = self.GetIssueURL() + '/description'
        self.description = urllib2.urlopen(url).read()
      self.has_description = True
    if pretty:
      wrapper = textwrap.TextWrapper()
      wrapper.initial_indent = wrapper.subsequent_indent = '  '
      return wrapper.fill(self.description)
    return self.description

  def SetIssue(self, issue):
    issuestore.SetIssue(self.GetBranchRef(), issue)
    self.has_issue = False

  def CloseIssue(self):
    def GetUserCredentials():
      email = raw_input('Email: ').strip()
      password = getpass.getpass('Password for %s: ' % email)
      return email, password

    rpc_server = upload.HttpRpcServer(settings.GetServer(),
                                      GetUserCredentials,
                                      host_override=settings.GetServer(),
                                      save_cookies=True)
    rpc_server.Send('/' + self.GetIssue() + '/close')


def CmdStatus(args):
  cl = Changelist()
  print 'Branch:', cl.GetBranch()
  if not cl.GetIssue():
    print 'No issue assigned.'
    return 0
  print 'Issue number:', cl.GetIssue(), '(%s)' % cl.GetIssueURL()
  print 'Issue description:'
  print cl.GetDescription(pretty=True)


def CmdIssue(args):
  cl = Changelist()
  if len(args) > 0:
    cl.SetIssue(int(args[0]))
  print 'Issue number:', cl.GetIssue(), '(%s)' % cl.GetIssueURL()


def CmdUpload(args):
  cl = Changelist()
  subprocess.call(['git', 'diff', '--stat'] + args)
  upload_args = ['--local_base']
  upload_args.extend(['--server', settings.GetServer()])
  upload_args.extend(['--cc', settings.GetCCList()])
  if cl.GetIssue():
    upload_args.extend(['--issue', cl.GetIssue()])
  issue = upload.RealMain(['upload'] + upload_args + args)
  if not cl.GetIssue():
    cl.SetIssue(issue)


def CmdDCommit(args):
  cl = Changelist()
  # It is important to have these checks at the top.  Not only for user
  # convenience, but also because the cl object then caches the correct values
  # of these fields even as we're juggling branches for setting up the commit.
  if not cl.GetIssue():
    print 'Current issue unknown -- has this branch been uploaded?'
    return 1
  if not cl.GetDescription():
    print 'No description set.'
    print 'Visit %s/edit to set it.' % (cl.GetIssueURL())
    return 1

  if RunCommand(['git', 'diff-index', 'HEAD']):
    print 'Cannot dcommit with a dirty tree.'
    return 1

  print 'Description:', repr(cl.GetDescription())

  # We want to squash all this branch's commits into one commit with the
  # proper description.
  # We do this by doing a "merge --squash" into a new commit branch, then
  # dcommitting that.
  MERGE_BRANCH = 'git-cl-commit'
  # Delete the merge branch if it already exists.
  if RunCommand(['git', 'show-ref', '--quiet', '--verify',
                 'refs/heads/' + MERGE_BRANCH], exit_code=True) == 0:
    RunCommand(['git', 'branch', '-D', MERGE_BRANCH])
  # Stuff our change into the merge branch.
  RunCommand(['git', 'checkout', '-q', '-b', MERGE_BRANCH, 'trunk'])
  RunCommand(['git', 'merge', '--squash', cl.GetBranchRef()])
  RunCommand(['git', 'commit', '-m', cl.GetDescription()])
  # dcommit the merge branch.
  RunCommand(['git', 'svn', 'dcommit'])
  # And then swap back to the original branch and clean up.
  RunCommand(['git', 'checkout', '-q', cl.GetBranch()])
  RunCommand(['git', 'branch', '-D', MERGE_BRANCH])
  issuestore.DropBranchIssue(cl.GetBranchRef())
  cl.CloseIssue()


def CmdPatch(args):
  def Usage():
    print 'usage: patch <url>'
    return 1
  if len(args) != 1:
    return Usage()
  url = args[0]
  match = re.search(r'issue(\d+)', url)
  if not match:
    print "couldn't find issue number in url!"
    return Usage()
  issue = int(match.group(1))
  #origbranch = RunCommand(['git', 'symbolic-ref', 'HEAD']).strip()
  newbranch = 'issue_%d' % issue
  RunCommand(['git', 'checkout', '-b', newbranch, 'trunk'])
  try:
    top = RunCommand(['git', 'rev-parse', '--show-cdup']).strip()
    if top:
      os.chdir(top)
    subprocess.check_call('curl --silent %s | patch -p0' % url, shell=True)
    RunCommand(['git', 'commit', '-a', '-m', 'patched from issue %d' % issue])
  except:
    #RunCommand(['git', 'checkout', '-f', origbranch])
    raise


COMMANDS = [
  ('status',  'show status of current changelist',           CmdStatus),
  ('issue',   'show/set current branch\'s issue number',     CmdIssue),
  ('upload',  'upload the current changelist to codereview', CmdUpload),
  ('dcommit', 'commit the current changelist via git-svn',   CmdDCommit),
  ('patch',   'patch in a code review',                      CmdPatch),
]


def Usage(name):
  print 'usage: %s <command>' % name
  print 'commands are:'
  for name, desc, _ in COMMANDS:
    print '  %-10s %s' % (name, desc)
  sys.exit(1)


def main(argv):
  if len(argv) < 2:
    Usage(argv[0])

  command = argv[1]
  for name, _, func in COMMANDS:
    if name == command:
      return func(argv[2:])
  print 'unknown command: %s' % command
  Usage(argv[0])


if __name__ == '__main__':
  sys.exit(main(sys.argv))
