#!/usr/bin/python
# git-cl -- a git-command for integrating reviews on Rietveld
# Copyright (C) 2008 Evan Martin <martine@danga.com>

import getpass
import optparse
import os
import re
import subprocess
import sys
import textwrap
import upload
import urllib2

VERBOSE=False

def RunGit(args, error_ok=False, error_message=None, exit_code=False):
  cmd = ['git'] + args
  if VERBOSE:
    print >>sys.stderr, ' '.join(cmd)
  proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
  output = proc.communicate()[0]
  if exit_code:
    return proc.returncode
  if not error_ok and proc.returncode != 0:
    print >>sys.stderr, 'Command "%s" failed.' % (' '.join(cmd))
    if error_message:
      print >>sys.stderr, error_message
    else:
      print >>sys.stderr, output
    sys.exit(1)
  return output


class Settings:
  def __init__(self):
    self.server = None
    self.cc = None
    self.svn_branch = None

  def GetServer(self):
    if not self.server:
      error_message = ('You must set your server with ' +
                       '"git config rietveld.server <hostname>[:<port>]".')
      self.server = self._GetConfig('rietveld.server',
                                    error_message=error_message)
    return self.server

  def GetCCList(self):
    if self.cc is None:
      self.cc = self._GetConfig('rietveld.cc', error_ok=True)
    return self.cc

  def GetSVNBranch(self):
    if self.svn_branch is None:
      # Fetch config is a refspec, of the form remotename:localname.
      self.svn_branch = self._GetConfig('svn-remote.svn.fetch').split(':')[1]
    return self.svn_branch

  def _GetConfig(self, param, **kwargs):
    return RunGit(['config', param], **kwargs).strip()

settings = Settings()


class IssueStore:
  def __init__(self):
    self.storepath = None
    self.issues = None

  def GetStorePath(self):
    if not self.storepath:
      gitdir = RunGit(['rev-parse', '--git-dir']).strip()
      self.storepath = os.path.join(gitdir, 'cl-mapping')
    return self.storepath

  def LoadIssues(self):
    self.issues = {}
    if not os.path.exists(self.GetStorePath()):
      return
    store = open(self.GetStorePath(), 'r')
    for line in store:
      branch, issue = line.split()
      self.issues[branch] = issue
    store.close()

  def LookupIssue(self, branch):
    if not self.issues:
      self.LoadIssues()
    if branch in self.issues:
      return self.issues[branch]
    return None

  def FlushIssues(self):
    store = open(self.GetStorePath(), 'w')
    for branch, issue in self.issues.items():
      store.write('%s %s\n' % (branch, issue))
    store.close()

  def SetIssue(self, branch, issue):
    if not self.issues:
      self.LoadIssues()
    self.issues[branch] = issue
    self.FlushIssues()

  def DropBranchIssue(self, branch):
    del self.issues[branch]
    self.FlushIssues()

issuestore = IssueStore()


class Changelist:
  def __init__(self):
    self.branch = None
    self.has_issue = False
    self.issue = self.GetIssue()
    self.has_description = False
    self.description = None

  def GetBranch(self):
    if not self.branch:
      self.branchref = RunGit(['symbolic-ref', 'HEAD']).strip()
      self.branch = self.branchref.replace('refs/heads/', '')
    return self.branch
  def GetBranchRef(self):
    self.GetBranch()
    return self.branchref

  def GetIssue(self):
    if not self.has_issue:
      self.issue = issuestore.LookupIssue(self.GetBranchRef())
      self.has_issue = True
    return self.issue

  def GetIssueURL(self):
    return 'http://%s/%s' % (settings.GetServer(), self.GetIssue())

  def GetDescription(self, pretty=False):
    if not self.has_description:
      if self.GetIssue():
        url = self.GetIssueURL() + '/description'
        self.description = urllib2.urlopen(url).read()
      self.has_description = True
    if pretty:
      wrapper = textwrap.TextWrapper()
      wrapper.initial_indent = wrapper.subsequent_indent = '  '
      return wrapper.fill(self.description)
    return self.description

  def SetIssue(self, issue):
    issuestore.SetIssue(self.GetBranchRef(), issue)
    self.has_issue = False

  def CloseIssue(self):
    def GetUserCredentials():
      email = raw_input('Email: ').strip()
      password = getpass.getpass('Password for %s: ' % email)
      return email, password

    rpc_server = upload.HttpRpcServer(settings.GetServer(),
                                      GetUserCredentials,
                                      host_override=settings.GetServer(),
                                      save_cookies=True)
    rpc_server.Send('/' + self.GetIssue() + '/close')


def CmdStatus(args):
  cl = Changelist()
  print 'Branch:', cl.GetBranch()
  if not cl.GetIssue():
    print 'No issue assigned.'
    return 0
  print 'Issue number:', cl.GetIssue(), '(%s)' % cl.GetIssueURL()
  print 'Issue description:'
  print cl.GetDescription(pretty=True)


def CmdIssue(args):
  cl = Changelist()
  if len(args) > 0:
    cl.SetIssue(int(args[0]))
  print 'Issue number:', cl.GetIssue(), '(%s)' % cl.GetIssueURL()


def CmdUpload(args):
  cl = Changelist()
  if not args:
    # Default to diffing against the SVN trunk.
    args = [settings.GetSVNBranch()]
  subprocess.call(['git', 'diff', '--stat'] + args)
  upload_args = ['--local_base']
  upload_args.extend(['--server', settings.GetServer()])
  upload_args.extend(['--cc', settings.GetCCList()])
  if cl.GetIssue():
    upload_args.extend(['--issue', cl.GetIssue()])
  issue = upload.RealMain(['upload'] + upload_args + args)
  if not cl.GetIssue():
    cl.SetIssue(issue)


def CmdDCommit(args):
  cl = Changelist()
  # It is important to have these checks at the top.  Not only for user
  # convenience, but also because the cl object then caches the correct values
  # of these fields even as we're juggling branches for setting up the commit.
  if not cl.GetIssue():
    print 'Current issue unknown -- has this branch been uploaded?'
    return 1
  if not cl.GetDescription():
    print 'No description set.'
    print 'Visit %s/edit to set it.' % (cl.GetIssueURL())
    return 1

  if RunGit(['diff-index', 'HEAD']):
    print 'Cannot dcommit with a dirty tree.'
    return 1

  description = cl.GetDescription()

  contributor = raw_input("External source of patch (enter for none): ")
  if contributor:
    description += "\n\nPatch from %s." % contributor
  print 'Description:', repr(description)

  raw_input("About to commit; enter to confirm.")
  # We want to squash all this branch's commits into one commit with the
  # proper description.
  # We do this by doing a "merge --squash" into a new commit branch, then
  # dcommitting that.
  MERGE_BRANCH = 'git-cl-commit'
  # Delete the merge branch if it already exists.
  if RunGit(['show-ref', '--quiet', '--verify', 'refs/heads/' + MERGE_BRANCH],
            exit_code=True) == 0:
    RunGit(['branch', '-D', MERGE_BRANCH])
  # Stuff our change into the merge branch.
  RunGit(['checkout', '-q', '-b', MERGE_BRANCH, settings.GetSVNBranch()])
  RunGit(['merge', '--squash', cl.GetBranchRef()])
  RunGit(['commit', '-m', description])
  # dcommit the merge branch.
  RunGit(['svn', 'dcommit'])
  # And then swap back to the original branch and clean up.
  RunGit(['checkout', '-q', cl.GetBranch()])
  RunGit(['branch', '-D', MERGE_BRANCH])
  issuestore.DropBranchIssue(cl.GetBranchRef())
  print "Closing issue (you may be prompted for your codereview password)..."
  cl.CloseIssue()


def CmdPatch(args):
  parser = optparse.OptionParser(usage='git cl patch [options] <patch url>')
  parser.add_option('-b', action='store_true', dest='newbranch',
                    help='create a new branch off trunk for the patch')
  parser.add_option('-f', action='store_true', dest='force',
                    help='with -b, clobber any existing branch')
  (options, args) = parser.parse_args(args)
  if len(args) != 1:
    return parser.print_help()
  url = args[0]

  issue = None
  if options.newbranch:
    # Figure out the issue number and branch name from the URL.
    match = re.search(r'issue(\d+)', url)
    if not match:
      print "couldn't find issue number in url!"
      return Usage()
    issue = int(match.group(1))
    newbranch = 'issue_%d' % issue
    if options.force:
      RunGit(['branch', '-D', newbranch], error_ok=True)
    RunGit(['checkout', '-b', newbranch, settings.GetSVNBranch()])

  # Switch up to the top-level directory, if necessary, in preparation for
  # applying the patch.
  top = RunGit(['rev-parse', '--show-cdup']).strip()
  if top:
    os.chdir(top)

  # Git patches have a/ at the beginning of source paths.  We strip that out
  # with a sed script rather than the -p flag to patch so we can feed either
  # Git or svn-style patches into the same patch command.
  gitsed = "sed -e 's|^--- a/|--- |'"
  subprocess.check_call('curl --silent %s | %s | patch -p0' % (url, gitsed),
                        shell=True)

  # If we had an issue, commit the current state and register the issue.
  if issue:
    RunGit(['commit', '-a', '-m', 'patch from issue %d' % issue])
    cl = Changelist()
    cl.SetIssue(issue)


COMMANDS = [
  ('status',  'show status of current changelist',           CmdStatus),
  ('issue',   'show/set current branch\'s issue number',     CmdIssue),
  ('upload',  'upload the current changelist to codereview', CmdUpload),
  ('dcommit', 'commit the current changelist via git-svn',   CmdDCommit),
  ('patch',   'patch in a code review',                      CmdPatch),
]


def Usage(name):
  print 'usage: %s <command>' % name
  print 'commands are:'
  for name, desc, _ in COMMANDS:
    print '  %-10s %s' % (name, desc)
  sys.exit(1)


def main(argv):
  if len(argv) < 2:
    Usage(argv[0])

  command = argv[1]
  for name, _, func in COMMANDS:
    if name == command:
      return func(argv[2:])
  print 'unknown command: %s' % command
  Usage(argv[0])


if __name__ == '__main__':
  sys.exit(main(sys.argv))
