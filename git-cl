#!/usr/bin/python
# git-cl -- a git-command for integrating reviews on Rietveld
# Copyright (C) 2008 Evan Martin <martine@danga.com>

import getpass
import optparse
import os
import re
import readline
import subprocess
import sys
import tempfile
import textwrap
import upload
import urllib2

DEFAULT_SERVER = 'codereview.appspot.com'

def RunGit(args, error_ok=False, error_message=None, exit_code=False):
  cmd = ['git'] + args
  # Useful for debugging:
  # print >>sys.stderr, ' '.join(cmd)
  proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
  output = proc.communicate()[0]
  if exit_code:
    return proc.returncode
  if not error_ok and proc.returncode != 0:
    print >>sys.stderr, 'Command "%s" failed.' % (' '.join(cmd))
    if error_message:
      print >>sys.stderr, error_message
    else:
      print >>sys.stderr, output
    sys.exit(1)
  return output


class Settings:
  def __init__(self):
    self.server = None
    self.cc = None
    self.svn_branch = None

  def GetServer(self, error_ok=False):
    if not self.server:
      if not error_ok:
        error_message = ('You must configure your review setup by running ' +
                         '"git cl config".')
        self.server = self._GetConfig('rietveld.server',
                                      error_message=error_message)
      else:
        self.server = self._GetConfig('rietveld.server', error_ok=True)
    return self.server

  def GetCCList(self):
    if self.cc is None:
      self.cc = self._GetConfig('rietveld.cc', error_ok=True)
    return self.cc

  def GetSVNBranch(self):
    if self.svn_branch is None:
      # Try to figure out which remote branch we're based on.

      # Get the refname and hash for all refs/remotes/*.
      remotes = RunGit(['for-each-ref', '--format=%(refname) %(objectname)',
                        'refs/remotes'])
      remote_refs = {}
      for ref, hash in [line.split(' ') for line in remotes.splitlines()]:
        # git-svn remote refs are generally directly in the refs/remotes/dir,
        # not a subdirectory (like refs/remotes/origin/master).
        if '/' in ref[len('refs/remotes/'):]:
          continue
        remote_refs[hash] = ref

      if len(remote_refs) == 1:
        # Only one remote branch exists -- seems like a good candidate.
        self.svn_branch = remote_refs.values()[0]
      elif len(remote_refs) > 1:
        # We have more than one remote branch available.  We need to guess
        # which one we're based off of.  git-svn does this by iterating
        # backwards through the log and looking for git-svn-id: lines.
        # We just want to match up to a git branch, so our job is easier.
        # We don't want to go through all of history, so read a line from the
        # pipe at a time.
        cmd = ['git', 'rev-list', 'HEAD']
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
        for line in proc.stdout:
          line = line.strip()
          if line in remote_refs:
            self.svn_branch = remote_refs[line]
            proc.stdout.close()  # Cut pipe.
            break

      if not self.svn_branch:
        # This code is still incorrect.  If you branched off from a remote
        # branch, then ran "git svn fetch" (so it moved forwards), then this
        # code won't figure out the right thing.  The proper fix is too hard
        # to implement right now.
        raise "Can't guess svn branch -- try specifying it on the command line"

    return self.svn_branch

  def _GetConfig(self, param, **kwargs):
    return RunGit(['config', param], **kwargs).strip()

settings = Settings()


class IssueStore:
  def __init__(self):
    self.storepath = None
    self.issues = None

  def GetStorePath(self):
    if not self.storepath:
      gitdir = RunGit(['rev-parse', '--git-dir']).strip()
      self.storepath = os.path.join(gitdir, 'cl-mapping')
    return self.storepath

  def LoadIssues(self):
    self.issues = {}
    if not os.path.exists(self.GetStorePath()):
      return
    store = open(self.GetStorePath(), 'r')
    for line in store:
      branch, issue = line.split()
      self.issues[branch] = issue
    store.close()

  def LookupIssue(self, branch):
    if not self.issues:
      self.LoadIssues()
    if branch in self.issues:
      return self.issues[branch]
    return None

  def FlushIssues(self):
    store = open(self.GetStorePath(), 'w')
    for branch, issue in self.issues.items():
      store.write('%s %s\n' % (branch, issue))
    store.close()

  def SetIssue(self, branch, issue):
    if not self.issues:
      self.LoadIssues()
    self.issues[branch] = issue
    self.FlushIssues()

  def DropBranchIssue(self, branch):
    del self.issues[branch]
    self.FlushIssues()

issuestore = IssueStore()


def IssueURL(issue):
  """Get the URL for a particular issue."""
  return 'http://%s/%s' % (settings.GetServer(), issue)


def ShortBranchName(branch):
  """Convert a name like 'refs/heads/foo' to just 'foo'."""
  return branch.replace('refs/heads/', '')


class Changelist:
  def __init__(self):
    # Poke settings so we get the "configure your server" message if necessary.
    settings.GetServer()
    self.branch = None
    self.upstream_branch = None
    self.has_issue = False
    self.issue = self.GetIssue()
    self.has_description = False
    self.description = None

  def GetBranch(self):
    if not self.branch:
      self.branchref = RunGit(['symbolic-ref', 'HEAD']).strip()
      self.branch = ShortBranchName(self.branchref)
    return self.branch
  def GetBranchRef(self):
    self.GetBranch()
    return self.branchref

  def GetUpstreamBranch(self):
    if self.upstream_branch is None:
      branch = self.GetBranch()
      error_message = """Unable to determine default branch to diff against.
Either pass complete "git diff"-style arguments, like
  git cl upload origin/master
or verify this branch is set up to track another (via the --track argument to
"git checkout -b ...")."""
      self.upstream_branch = RunGit(['config', 'branch.%s.merge' % branch],
                                    error_message=error_message).strip()
    return self.upstream_branch

  def GetIssue(self):
    if not self.has_issue:
      self.issue = issuestore.LookupIssue(self.GetBranchRef())
      self.has_issue = True
    return self.issue

  def GetIssueURL(self):
    return IssueURL(self.GetIssue())

  def GetDescription(self, pretty=False):
    if not self.has_description:
      if self.GetIssue():
        url = self.GetIssueURL() + '/description'
        self.description = urllib2.urlopen(url).read().strip()
      self.has_description = True
    if pretty:
      wrapper = textwrap.TextWrapper()
      wrapper.initial_indent = wrapper.subsequent_indent = '  '
      return wrapper.fill(self.description)
    return self.description

  def SetIssue(self, issue):
    issuestore.SetIssue(self.GetBranchRef(), issue)
    self.has_issue = False

  def CloseIssue(self):
    def GetUserCredentials():
      email = raw_input('Email: ').strip()
      password = getpass.getpass('Password for %s: ' % email)
      return email, password

    rpc_server = upload.HttpRpcServer(settings.GetServer(),
                                      GetUserCredentials,
                                      host_override=settings.GetServer(),
                                      save_cookies=True)
    # You cannot close an issue with a GET.
    # We pass an empty string for the data so it is a POST rather than a GET.
    rpc_server.Send('/' + self.GetIssue() + '/close', '')


def CmdConfig(args):
  server = settings.GetServer(error_ok=True)
  prompt = 'Rietveld server (host[:port])'
  prompt += ' [%s]' % (server or DEFAULT_SERVER)
  newserver = raw_input(prompt + ': ')
  if not server and not newserver:
    newserver = DEFAULT_SERVER
  if newserver and newserver != server:
    RunGit(['config', 'rietveld.server', newserver])

  cclist = settings.GetCCList()
  prompt = 'CC list'
  if cclist:
    prompt += ' ("x" to clear) [%s]' % cclist
  newcclist = raw_input(prompt + ': ')
  if newcclist and newcclist != cclist or newcclist == 'x':
    if newcclist == 'x':
      RunGit(['config', '--unset-all', 'rietveld.cc'], error_ok=True)
    else:
      RunGit(['config', 'rietveld.cc', newcclist])

  # TODO: configure a default branch to diff against, rather than this
  # svn-based hackery.


def CmdStatus(args):
  issuestore.LoadIssues()
  if issuestore.issues:
    print 'Branches associated with reviews:'
    for branch in sorted(issuestore.issues.keys()):
      print "  %10s: %s" % (ShortBranchName(branch),
                            IssueURL(issuestore.issues[branch]))

  cl = Changelist()
  print
  print 'Current branch:',
  if not cl.GetIssue():
    print 'no issue assigned.'
    return 0
  print cl.GetBranch()
  print 'Issue number:', cl.GetIssue(), '(%s)' % cl.GetIssueURL()
  print 'Issue description:'
  print cl.GetDescription(pretty=True)


def CmdIssue(args):
  cl = Changelist()
  if len(args) > 0:
    cl.SetIssue(int(args[0]))
  print 'Issue number:', cl.GetIssue(), '(%s)' % cl.GetIssueURL()


def UserEditedLog(starting_text):
  """Given some starting text, let the user edit it and return the result."""
  editor = os.getenv('EDITOR', 'vi')

  file = tempfile.NamedTemporaryFile()
  filename = file.name
  file.write(starting_text)
  file.flush()

  ret = subprocess.call([editor, filename])
  if ret != 0:
    return

  text = open(filename).read()
  file.close()
  stripcomment_re = re.compile(r'^#.*$', re.MULTILINE)
  return stripcomment_re.sub('', text).strip()


def CmdUpload(args):
  parser = optparse.OptionParser(
      usage='git cl upload [options] [args to "git diff"]')
  parser.add_option('-m', dest='message', help='message for patch')
  (options, args) = parser.parse_args(args)

  cl = Changelist()
  if not args:
    # Default to diffing against the "upstream" branch.
    args = [cl.GetUpstreamBranch()]
  subprocess.call(['git', 'diff', '--stat'] + args)
  upload_args = ['--assume_yes']  # Don't ask about untracked files.
  upload_args.extend(['--server', settings.GetServer()])
  upload_args.extend(['--cc', settings.GetCCList()])
  if options.message:
    upload_args.extend(['--message', options.message])
  if cl.GetIssue():
    upload_args.extend(['--issue', cl.GetIssue()])
  else:
    # Construct a description for this change from the log.
    # We need to convert diff options to log options.
    log_args = []
    if len(args) == 1 and not args[0].endswith('.'):
      log_args = [args[0] + '..']
    elif len(args) == 2:
      log_args = [args[0] + '..' + args[1]]
    else:
      log_args = args[:]  # Hope for the best!
    desc = RunGit(['log', '--pretty=format:* %s\n%b'] + log_args)
    initial_text = """# Enter a description of the change.
# This will displayed on the codereview site.
# The first line will also be used as the subject of the review."""
    desc = UserEditedLog(initial_text + '\n' + desc)
    if not desc:
      print "Description empty; aborting."
      return 1
    subject = desc.splitlines()[0]
    upload_args.extend(['--message', subject])
    upload_args.extend(['--description', desc])
  issue = upload.RealMain(['upload'] + upload_args + args)
  if not cl.GetIssue():
    cl.SetIssue(issue)


def CmdDCommit(args):
  parser = optparse.OptionParser(
      usage='git cl dcommit [options] [git-svn branch to apply against]')
  parser.add_option('-f', action='store_true', dest='force',
                    help="force yes to questions (don't prompt)")
  parser.add_option('-c', dest='contributor',
                    help="external contributor for patch (appended to " +
                         "description)")
  (options, args) = parser.parse_args(args)

  if not args:
    # Default to merging against our best guess of the SVN branch.
    args = [settings.GetSVNBranch()]

  base_branch = args[0]

  cl = Changelist()
  # It is important to have these checks at the top.  Not only for user
  # convenience, but also because the cl object then caches the correct values
  # of these fields even as we're juggling branches for setting up the commit.
  if not cl.GetIssue():
    print 'Current issue unknown -- has this branch been uploaded?'
    return 1
  if not cl.GetDescription():
    print 'No description set.'
    print 'Visit %s/edit to set it.' % (cl.GetIssueURL())
    return 1

  if RunGit(['diff-index', 'HEAD']):
    print 'Cannot dcommit with a dirty tree.  You must commit locally first.'
    return 1

  description = cl.GetDescription()

  if options.contributor:
    description += "\n\nPatch from %s." % contributor
  print 'Description:', repr(description)

  if not options.force:
    raw_input("About to commit; enter to confirm.")
  # We want to squash all this branch's commits into one commit with the
  # proper description.
  # We do this by doing a "merge --squash" into a new commit branch, then
  # dcommitting that.
  MERGE_BRANCH = 'git-cl-commit'
  # Delete the merge branch if it already exists.
  if RunGit(['show-ref', '--quiet', '--verify', 'refs/heads/' + MERGE_BRANCH],
            exit_code=True) == 0:
    RunGit(['branch', '-D', MERGE_BRANCH])
  # Stuff our change into the merge branch.
  RunGit(['checkout', '-q', '-b', MERGE_BRANCH, base_branch])
  RunGit(['merge', '--squash', cl.GetBranchRef()])
  RunGit(['commit', '-m', description])
  # dcommit the merge branch.
  RunGit(['svn', 'dcommit'])
  # And then swap back to the original branch and clean up.
  RunGit(['checkout', '-q', cl.GetBranch()])
  RunGit(['branch', '-D', MERGE_BRANCH])
  issuestore.DropBranchIssue(cl.GetBranchRef())
  print "Closing issue (you may be prompted for your codereview password)..."
  cl.CloseIssue()


def CmdPatch(args):
  parser = optparse.OptionParser(usage='git cl patch [options] <patch url>')
  parser.add_option('-b', action='store_true', dest='newbranch',
                    help='create a new branch off trunk for the patch')
  parser.add_option('-f', action='store_true', dest='force',
                    help='with -b, clobber any existing branch')
  (options, args) = parser.parse_args(args)
  if len(args) != 1:
    return parser.print_help()
  url = args[0]

  issue = None
  if options.newbranch:
    # Figure out the issue number and branch name from the URL.
    match = re.search(r'issue(\d+)', url)
    if not match:
      print "couldn't find issue number in url!"
      return Usage()
    issue = int(match.group(1))
    newbranch = 'issue%d' % issue
    if options.force:
      RunGit(['branch', '-D', newbranch], error_ok=True)
    RunGit(['checkout', '-b', newbranch, settings.GetSVNBranch()])

  # Switch up to the top-level directory, if necessary, in preparation for
  # applying the patch.
  top = RunGit(['rev-parse', '--show-cdup']).strip()
  if top:
    os.chdir(top)

  # Git patches have a/ at the beginning of source paths.  We strip that out
  # with a sed script rather than the -p flag to patch so we can feed either
  # Git or svn-style patches into the same patch command.
  gitsed = "sed -e 's|^--- a/|--- |; s|^+++ b/|+++ |'"
  subprocess.check_call('curl --silent %s | %s | patch -p0' % (url, gitsed),
                        shell=True)

  # If we had an issue, commit the current state and register the issue.
  if issue:
    RunGit(['commit', '-a', '-m', 'patch from issue %d' % issue])
    cl = Changelist()
    cl.SetIssue(issue)


COMMANDS = [
  ('config',  'edit configuration for this tree',            CmdConfig),
  ('status',  'show status of changelists',                  CmdStatus),
  ('issue',   'show/set current branch\'s issue number',     CmdIssue),
  ('upload',  'upload the current changelist to codereview', CmdUpload),
  ('dcommit', 'commit the current changelist via git-svn',   CmdDCommit),
  ('patch',   'patch in a code review',                      CmdPatch),
]


def Usage(name):
  print 'usage: %s <command>' % name
  print 'commands are:'
  for name, desc, _ in COMMANDS:
    print '  %-10s %s' % (name, desc)
  sys.exit(1)


def main(argv):
  if len(argv) < 2:
    Usage(argv[0])

  command = argv[1]
  for name, _, func in COMMANDS:
    if name == command:
      return func(argv[2:])
  print 'unknown command: %s' % command
  Usage(argv[0])


if __name__ == '__main__':
  sys.exit(main(sys.argv))
